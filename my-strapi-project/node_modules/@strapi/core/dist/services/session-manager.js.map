{"version":3,"file":"session-manager.js","sources":["../../src/services/session-manager.ts"],"sourcesContent":["import crypto from 'crypto';\nimport jwt from 'jsonwebtoken';\nimport type { VerifyOptions } from 'jsonwebtoken';\nimport type { Database } from '@strapi/database';\nimport { DEFAULT_ALGORITHM } from '../constants';\n\nexport interface SessionProvider {\n  create(session: SessionData): Promise<SessionData>;\n  findBySessionId(sessionId: string): Promise<SessionData | null>;\n  updateBySessionId(sessionId: string, data: Partial<SessionData>): Promise<void>;\n  deleteBySessionId(sessionId: string): Promise<void>;\n  deleteExpired(): Promise<void>;\n  deleteBy(criteria: { userId?: string; origin?: string; deviceId?: string }): Promise<void>;\n}\n\nexport interface SessionData {\n  id?: string;\n  userId: string; // User ID stored as string (key-value store)\n  sessionId: string;\n  deviceId?: string; // Optional for origins that don't need device tracking\n  origin: string;\n  childId?: string | null;\n\n  type?: 'refresh' | 'session';\n  status?: 'active' | 'rotated' | 'revoked';\n  expiresAt: Date;\n  absoluteExpiresAt?: Date | null;\n  createdAt?: Date;\n  updatedAt?: Date;\n}\n\nexport interface RefreshTokenPayload {\n  userId: string;\n  sessionId: string;\n  type: 'refresh';\n  exp: number;\n  iat: number;\n}\n\nexport interface AccessTokenPayload {\n  userId: string;\n  sessionId: string;\n  type: 'access';\n  exp: number;\n  iat: number;\n}\n\nexport type TokenPayload = RefreshTokenPayload | AccessTokenPayload;\n\nexport interface ValidateRefreshTokenResult {\n  isValid: boolean;\n  userId?: string;\n  sessionId?: string;\n  error?:\n    | 'invalid_token'\n    | 'token_expired'\n    | 'session_not_found'\n    | 'session_expired'\n    | 'wrong_token_type';\n}\n\nclass DatabaseSessionProvider implements SessionProvider {\n  private db: Database;\n\n  private contentType: string;\n\n  constructor(db: Database, contentType: string) {\n    this.db = db;\n    this.contentType = contentType;\n  }\n\n  async create(session: SessionData): Promise<SessionData> {\n    const result = await this.db.query(this.contentType).create({\n      data: session,\n    });\n    return result as SessionData;\n  }\n\n  async findBySessionId(sessionId: string): Promise<SessionData | null> {\n    const result = await this.db.query(this.contentType).findOne({\n      where: { sessionId },\n    });\n    return result as SessionData | null;\n  }\n\n  async updateBySessionId(sessionId: string, data: Partial<SessionData>): Promise<void> {\n    await this.db.query(this.contentType).update({ where: { sessionId }, data });\n  }\n\n  async deleteBySessionId(sessionId: string): Promise<void> {\n    await this.db.query(this.contentType).delete({\n      where: { sessionId },\n    });\n  }\n\n  async deleteExpired(): Promise<void> {\n    await this.db.query(this.contentType).deleteMany({\n      where: { absoluteExpiresAt: { $lt: new Date() } },\n    });\n  }\n\n  async deleteBy(criteria: { userId?: string; origin?: string; deviceId?: string }): Promise<void> {\n    await this.db.query(this.contentType).deleteMany({\n      where: {\n        ...(criteria.userId ? { userId: criteria.userId } : {}),\n        ...(criteria.origin ? { origin: criteria.origin } : {}),\n        ...(criteria.deviceId ? { deviceId: criteria.deviceId } : {}),\n      },\n    });\n  }\n}\n\nexport interface SessionManagerConfig {\n  jwtSecret: string;\n  accessTokenLifespan: number;\n  maxRefreshTokenLifespan: number;\n  idleRefreshTokenLifespan: number;\n  maxSessionLifespan: number;\n  idleSessionLifespan: number;\n}\n\nclass OriginSessionManager {\n  constructor(\n    private sessionManager: SessionManager,\n    private origin: string\n  ) {}\n\n  async generateRefreshToken(\n    userId: string,\n    deviceId: string | undefined,\n    options?: { type?: 'refresh' | 'session' }\n  ): Promise<{ token: string; sessionId: string; absoluteExpiresAt: string }> {\n    return this.sessionManager.generateRefreshToken(userId, deviceId, this.origin, options);\n  }\n\n  async generateAccessToken(refreshToken: string): Promise<{ token: string } | { error: string }> {\n    return this.sessionManager.generateAccessToken(refreshToken, this.origin);\n  }\n\n  async rotateRefreshToken(refreshToken: string): Promise<\n    | {\n        token: string;\n        sessionId: string;\n        absoluteExpiresAt: string;\n        type: 'refresh' | 'session';\n      }\n    | { error: string }\n  > {\n    return this.sessionManager.rotateRefreshToken(refreshToken, this.origin);\n  }\n\n  validateAccessToken(\n    token: string\n  ): { isValid: true; payload: AccessTokenPayload } | { isValid: false; payload: null } {\n    return this.sessionManager.validateAccessToken(token, this.origin);\n  }\n\n  async validateRefreshToken(token: string): Promise<ValidateRefreshTokenResult> {\n    return this.sessionManager.validateRefreshToken(token, this.origin);\n  }\n\n  async invalidateRefreshToken(userId: string, deviceId?: string): Promise<void> {\n    return this.sessionManager.invalidateRefreshToken(this.origin, userId, deviceId);\n  }\n\n  /**\n   * Returns true when a session exists and is not expired for this origin.\n   * If the session exists but is expired, it will be deleted as part of this check.\n   */\n  async isSessionActive(sessionId: string): Promise<boolean> {\n    return this.sessionManager.isSessionActive(sessionId, this.origin);\n  }\n}\n\nclass SessionManager {\n  private provider: SessionProvider;\n\n  // Store origin-specific configurations\n  private originConfigs: Map<string, SessionManagerConfig> = new Map();\n\n  // Run expired cleanup only every N calls to avoid extra queries\n  private cleanupInvocationCounter: number = 0;\n\n  private readonly cleanupEveryCalls: number = 50;\n\n  constructor(provider: SessionProvider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Define configuration for a specific origin\n   */\n  defineOrigin(origin: string, config: SessionManagerConfig): void {\n    this.originConfigs.set(origin, config);\n  }\n\n  /**\n   * Check if an origin is defined\n   */\n  hasOrigin(origin: string): boolean {\n    return this.originConfigs.has(origin);\n  }\n\n  /**\n   * Get configuration for a specific origin, throw error if not defined\n   */\n  private getConfigForOrigin(origin: string): SessionManagerConfig {\n    const originConfig = this.originConfigs.get(origin);\n    if (originConfig) {\n      return originConfig;\n    }\n    throw new Error(\n      `SessionManager: Origin '${origin}' is not defined. Please define it using defineOrigin('${origin}', config).`\n    );\n  }\n\n  generateSessionId(): string {\n    return crypto.randomBytes(16).toString('hex');\n  }\n\n  private async maybeCleanupExpired(): Promise<void> {\n    this.cleanupInvocationCounter += 1;\n    if (this.cleanupInvocationCounter >= this.cleanupEveryCalls) {\n      this.cleanupInvocationCounter = 0;\n\n      await this.provider.deleteExpired();\n    }\n  }\n\n  /**\n   * Get the cleanup every calls threshold\n   */\n  get cleanupThreshold(): number {\n    return this.cleanupEveryCalls;\n  }\n\n  async generateRefreshToken(\n    userId: string,\n    deviceId: string | undefined,\n    origin: string,\n    options?: { type?: 'refresh' | 'session' }\n  ): Promise<{ token: string; sessionId: string; absoluteExpiresAt: string }> {\n    if (!origin || typeof origin !== 'string') {\n      throw new Error(\n        'SessionManager: Origin parameter is required and must be a non-empty string'\n      );\n    }\n\n    await this.maybeCleanupExpired();\n\n    const config = this.getConfigForOrigin(origin);\n    const sessionId = this.generateSessionId();\n    const tokenType = options?.type ?? 'refresh';\n    const isRefresh = tokenType === 'refresh';\n\n    const idleLifespan = isRefresh ? config.idleRefreshTokenLifespan : config.idleSessionLifespan;\n\n    const maxLifespan = isRefresh ? config.maxRefreshTokenLifespan : config.maxSessionLifespan;\n\n    const now = Date.now();\n    const expiresAt = new Date(now + idleLifespan * 1000);\n    const absoluteExpiresAt = new Date(now + maxLifespan * 1000);\n\n    // Create the root record first so createdAt can be used for signing.\n    const record = await this.provider.create({\n      userId,\n      sessionId,\n      ...(deviceId && { deviceId }),\n      origin,\n      childId: null,\n      type: tokenType,\n      status: 'active',\n      expiresAt,\n      absoluteExpiresAt,\n    });\n\n    const issuedAtSeconds = Math.floor(new Date(record.createdAt ?? new Date()).getTime() / 1000);\n    const expiresAtSeconds = Math.floor(new Date(record.expiresAt).getTime() / 1000);\n\n    const payload: RefreshTokenPayload = {\n      userId,\n      sessionId,\n      type: 'refresh',\n      iat: issuedAtSeconds,\n      exp: expiresAtSeconds,\n    };\n\n    const token = jwt.sign(payload, config.jwtSecret, {\n      algorithm: DEFAULT_ALGORITHM,\n      noTimestamp: true,\n    });\n\n    return {\n      token,\n      sessionId,\n      absoluteExpiresAt: absoluteExpiresAt.toISOString(),\n    };\n  }\n\n  validateAccessToken(\n    token: string,\n    origin: string\n  ): { isValid: true; payload: AccessTokenPayload } | { isValid: false; payload: null } {\n    if (!origin || typeof origin !== 'string') {\n      throw new Error(\n        'SessionManager: Origin parameter is required and must be a non-empty string'\n      );\n    }\n\n    try {\n      const config = this.getConfigForOrigin(origin);\n      const payload = jwt.verify(token, config.jwtSecret, {\n        algorithms: [DEFAULT_ALGORITHM],\n      }) as TokenPayload;\n\n      // Ensure this is an access token\n      if (!payload || payload.type !== 'access') {\n        return { isValid: false, payload: null };\n      }\n\n      return { isValid: true, payload };\n    } catch (err) {\n      return { isValid: false, payload: null };\n    }\n  }\n\n  async validateRefreshToken(token: string, origin: string): Promise<ValidateRefreshTokenResult> {\n    if (!origin || typeof origin !== 'string') {\n      throw new Error(\n        'SessionManager: Origin parameter is required and must be a non-empty string'\n      );\n    }\n\n    try {\n      const config = this.getConfigForOrigin(origin);\n      const verifyOptions: VerifyOptions = {\n        algorithms: [DEFAULT_ALGORITHM],\n      };\n\n      const payload = jwt.verify(token, config.jwtSecret, verifyOptions) as RefreshTokenPayload;\n\n      if (payload.type !== 'refresh') {\n        return { isValid: false };\n      }\n\n      const session = await this.provider.findBySessionId(payload.sessionId);\n      if (!session) {\n        return { isValid: false };\n      }\n\n      const now = new Date();\n      if (new Date(session.expiresAt) <= now) {\n        return { isValid: false };\n      }\n\n      // Absolute family expiry check\n      if (session.absoluteExpiresAt && new Date(session.absoluteExpiresAt) <= now) {\n        return { isValid: false };\n      }\n\n      // Only 'active' sessions are eligible to create access tokens.\n      if (session.status !== 'active') {\n        return { isValid: false };\n      }\n\n      if (session.userId !== payload.userId) {\n        return { isValid: false };\n      }\n\n      return {\n        isValid: true,\n        userId: payload.userId,\n        sessionId: payload.sessionId,\n      };\n    } catch (error: any) {\n      if (error instanceof jwt.JsonWebTokenError) {\n        return { isValid: false };\n      }\n\n      throw error;\n    }\n  }\n\n  async invalidateRefreshToken(origin: string, userId: string, deviceId?: string): Promise<void> {\n    await this.provider.deleteBy({ userId, origin, deviceId });\n  }\n\n  async generateAccessToken(\n    refreshToken: string,\n    origin: string\n  ): Promise<{ token: string } | { error: string }> {\n    if (!origin || typeof origin !== 'string') {\n      throw new Error(\n        'SessionManager: Origin parameter is required and must be a non-empty string'\n      );\n    }\n\n    const validation = await this.validateRefreshToken(refreshToken, origin);\n\n    if (!validation.isValid) {\n      return { error: 'invalid_refresh_token' };\n    }\n\n    const payload: Omit<AccessTokenPayload, 'iat' | 'exp'> = {\n      userId: String(validation.userId!),\n      sessionId: validation.sessionId!,\n      type: 'access',\n    };\n\n    const config = this.getConfigForOrigin(origin);\n    const token = jwt.sign(payload, config.jwtSecret, {\n      algorithm: DEFAULT_ALGORITHM,\n      expiresIn: config.accessTokenLifespan,\n    });\n\n    return { token };\n  }\n\n  async rotateRefreshToken(\n    refreshToken: string,\n    origin: string\n  ): Promise<\n    | {\n        token: string;\n        sessionId: string;\n        absoluteExpiresAt: string;\n        type: 'refresh' | 'session';\n      }\n    | { error: string }\n  > {\n    if (!origin || typeof origin !== 'string') {\n      throw new Error(\n        'SessionManager: Origin parameter is required and must be a non-empty string'\n      );\n    }\n\n    try {\n      const config = this.getConfigForOrigin(origin);\n      const payload = jwt.verify(refreshToken, config.jwtSecret, {\n        algorithms: [DEFAULT_ALGORITHM],\n      }) as RefreshTokenPayload;\n\n      if (!payload || payload.type !== 'refresh') {\n        return { error: 'invalid_refresh_token' };\n      }\n\n      const current = await this.provider.findBySessionId(payload.sessionId);\n      if (!current) {\n        return { error: 'invalid_refresh_token' };\n      }\n\n      // If parent already has a child, return the same child token\n      if (current.childId) {\n        const child = await this.provider.findBySessionId(current.childId);\n\n        if (child) {\n          const childIat = Math.floor(new Date(child.createdAt ?? new Date()).getTime() / 1000);\n          const childExp = Math.floor(new Date(child.expiresAt).getTime() / 1000);\n\n          const childPayload: RefreshTokenPayload = {\n            userId: child.userId,\n            sessionId: child.sessionId,\n            type: 'refresh',\n            iat: childIat,\n            exp: childExp,\n          };\n\n          const childToken = jwt.sign(childPayload, config.jwtSecret, {\n            algorithm: DEFAULT_ALGORITHM,\n            noTimestamp: true,\n          });\n\n          let absoluteExpiresAt;\n          if (child.absoluteExpiresAt) {\n            absoluteExpiresAt =\n              typeof child.absoluteExpiresAt === 'string'\n                ? child.absoluteExpiresAt\n                : child.absoluteExpiresAt.toISOString();\n          } else {\n            absoluteExpiresAt = new Date(0).toISOString();\n          }\n\n          return {\n            token: childToken,\n            sessionId: child.sessionId,\n            absoluteExpiresAt,\n            type: child.type ?? 'refresh',\n          };\n        }\n      }\n\n      const now = Date.now();\n      const tokenType = current.type ?? 'refresh';\n      const idleLifespan =\n        tokenType === 'refresh' ? config.idleRefreshTokenLifespan : config.idleSessionLifespan;\n\n      // Enforce idle window since creation of the current token\n      if (current.createdAt && now - new Date(current.createdAt).getTime() > idleLifespan * 1000) {\n        return { error: 'idle_window_elapsed' };\n      }\n\n      // Enforce max family window using absoluteExpiresAt\n      const absolute = current.absoluteExpiresAt\n        ? new Date(current.absoluteExpiresAt).getTime()\n        : now;\n      if (absolute <= now) {\n        return { error: 'max_window_elapsed' };\n      }\n\n      // Create child token\n      const childSessionId = this.generateSessionId();\n      const childExpiresAt = new Date(now + idleLifespan * 1000);\n\n      const childRecord = await this.provider.create({\n        userId: current.userId,\n        sessionId: childSessionId,\n        ...(current.deviceId && { deviceId: current.deviceId }),\n        origin: current.origin,\n        childId: null,\n        type: tokenType,\n        status: 'active',\n        expiresAt: childExpiresAt,\n        absoluteExpiresAt: current.absoluteExpiresAt ?? new Date(absolute),\n      });\n\n      const childIat = Math.floor(new Date(childRecord.createdAt ?? new Date()).getTime() / 1000);\n      const childExp = Math.floor(new Date(childRecord.expiresAt).getTime() / 1000);\n      const payloadOut: RefreshTokenPayload = {\n        userId: current.userId,\n        sessionId: childSessionId,\n        type: 'refresh',\n        iat: childIat,\n        exp: childExp,\n      };\n      const childToken = jwt.sign(payloadOut, config.jwtSecret, {\n        algorithm: DEFAULT_ALGORITHM,\n        noTimestamp: true,\n      });\n\n      await this.provider.updateBySessionId(current.sessionId, {\n        status: 'rotated',\n        childId: childSessionId,\n      });\n\n      let absoluteExpiresAt;\n      if (childRecord.absoluteExpiresAt) {\n        absoluteExpiresAt =\n          typeof childRecord.absoluteExpiresAt === 'string'\n            ? childRecord.absoluteExpiresAt\n            : childRecord.absoluteExpiresAt.toISOString();\n      } else {\n        absoluteExpiresAt = new Date(absolute).toISOString();\n      }\n\n      return {\n        token: childToken,\n        sessionId: childSessionId,\n        absoluteExpiresAt,\n        type: tokenType,\n      };\n    } catch {\n      return { error: 'invalid_refresh_token' };\n    }\n  }\n\n  /**\n   * Returns true when a session exists and is not expired.\n   * If the session exists but is expired, it will be deleted as part of this check.\n   */\n  async isSessionActive(sessionId: string, origin: string): Promise<boolean> {\n    const session = await this.provider.findBySessionId(sessionId);\n    if (!session) {\n      return false;\n    }\n\n    if (session.origin !== origin) {\n      return false;\n    }\n\n    if (new Date(session.expiresAt) <= new Date()) {\n      // Clean up expired session eagerly\n      await this.provider.deleteBySessionId(sessionId);\n\n      return false;\n    }\n\n    return true;\n  }\n}\n\nconst createDatabaseProvider = (db: Database, contentType: string): SessionProvider => {\n  return new DatabaseSessionProvider(db, contentType);\n};\n\nconst createSessionManager = ({\n  db,\n}: {\n  db: Database;\n}): SessionManager & ((origin: string) => OriginSessionManager) => {\n  const provider = createDatabaseProvider(db, 'admin::session');\n  const sessionManager = new SessionManager(provider);\n\n  // Add callable functionality\n  const fluentApi = (origin: string): OriginSessionManager => {\n    if (!origin || typeof origin !== 'string') {\n      throw new Error(\n        'SessionManager: Origin parameter is required and must be a non-empty string'\n      );\n    }\n    return new OriginSessionManager(sessionManager, origin);\n  };\n\n  // Attach only the public SessionManagerService API to the callable\n  const api = fluentApi as unknown as any;\n  api.generateSessionId = sessionManager.generateSessionId.bind(sessionManager);\n  api.defineOrigin = sessionManager.defineOrigin.bind(sessionManager);\n  api.hasOrigin = sessionManager.hasOrigin.bind(sessionManager);\n  // Note: isSessionActive is origin-scoped and exposed on OriginSessionManager only\n\n  // Forward the cleanupThreshold getter (used in tests)\n  Object.defineProperty(api, 'cleanupThreshold', {\n    get() {\n      return sessionManager.cleanupThreshold;\n    },\n    enumerable: true,\n  });\n\n  return api as SessionManager & ((origin: string) => OriginSessionManager);\n};\n\nexport { createSessionManager, createDatabaseProvider };\n"],"names":["DatabaseSessionProvider","create","session","result","db","query","contentType","data","findBySessionId","sessionId","findOne","where","updateBySessionId","update","deleteBySessionId","delete","deleteExpired","deleteMany","absoluteExpiresAt","$lt","Date","deleteBy","criteria","userId","origin","deviceId","constructor","OriginSessionManager","generateRefreshToken","options","sessionManager","generateAccessToken","refreshToken","rotateRefreshToken","validateAccessToken","token","validateRefreshToken","invalidateRefreshToken","isSessionActive","SessionManager","defineOrigin","config","originConfigs","set","hasOrigin","has","getConfigForOrigin","originConfig","get","Error","generateSessionId","crypto","randomBytes","toString","maybeCleanupExpired","cleanupInvocationCounter","cleanupEveryCalls","provider","cleanupThreshold","tokenType","type","isRefresh","idleLifespan","idleRefreshTokenLifespan","idleSessionLifespan","maxLifespan","maxRefreshTokenLifespan","maxSessionLifespan","now","expiresAt","record","childId","status","issuedAtSeconds","Math","floor","createdAt","getTime","expiresAtSeconds","payload","iat","exp","jwt","sign","jwtSecret","algorithm","DEFAULT_ALGORITHM","noTimestamp","toISOString","verify","algorithms","isValid","err","verifyOptions","error","JsonWebTokenError","validation","String","expiresIn","accessTokenLifespan","current","child","childIat","childExp","childPayload","childToken","absolute","childSessionId","childExpiresAt","childRecord","payloadOut","Map","createDatabaseProvider","createSessionManager","fluentApi","api","bind","Object","defineProperty","enumerable"],"mappings":"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"}